

실행 방법

//필요한 테이블 1
CREATE TABLE GUESTCUSTOM
(ID VARCHAR2(20) PRIMARY KEY, 
PW VARCHAR2(20), 
NAME VARCHAR2(10));

//필요한 테이블 1
CREATE TABLE GUESTRECORD
(ID VARCHAR2(20) PRIMARY KEY,
G_CONTENT VARCHAR2(1000),
CREATED DATE,
CONSTRAINT GUEST_ID_FK FOREIGN KEY (ID)
REFERENCES GUESTCUSTOM(ID));

//제약조건 추가
ALTER TABLE GUESTCUSTOM MODIFY PW NOT NULL;
ALTER TABLE GUESTCUSTOM MODIFY NAME NOT NULL;


--CallableStatement 방법을 쓰기위한 프로시저들

--writeInfo(?,?,?)
CREATE OR REPLACE PROCEDURE WRITEINFO
(ID IN GUESTCUSTOM.ID%TYPE,
PW IN GUESTCUSTOM.PW%TYPE,
NAME IN GUESTCUSTOM.NAME%TYPE)
IS
BEGIN
INSERT INTO GUESTCUSTOM
VALUES (ID, PW, NAME);
COMMIT;
END;

--updateRecord(?, ?, ?)
CREATE OR REPLACE PROCEDURE UPDATERECORD
(ID IN GUESTRECORD.ID%TYPE,
G_CONTENT IN GUESTRECORD.G_CONTENT%TYPE)
IS
BEGIN
UPDATE GUESTRECORD R SET R.ID = UPDATERECORD.ID, R.G_CONTENT = UPDATERECORD.G_CONTENT, R.CREATED = SYSDATE WHERE ID = UPDATERECORD.ID;
COMMIT;
END;

--searchID(?, ?)
CREATE OR REPLACE PROCEDURE SEARCHID
(PRESULT OUT SYS_REFCURSOR,
ID IN GUESTCUSTOM.ID%TYPE)
IS
BEGIN
OPEN PRESULT FOR
SELECT C.ID, C.PW, C.NAME, R.G_CONTENT, R.CREATED
FROM GUESTCUSTOM C, GUESTRECORD R WHERE C.ID = SEARCHID.ID AND R.ID = SEARCHID.ID;
END;

--updateInfo(?, ?, ?)
CREATE OR REPLACE PROCEDURE UPDATEINFO
(ID IN GUESTCUSTOM.ID%TYPE,
PW IN GUESTCUSTOM.PW%TYPE,
NAME IN GUESTCUSTOM.NAME%TYPE)
IS
BEGIN
UPDATE GUESTCUSTOM C SET C.ID = UPDATEINFO.ID, C.PW = UPDATEINFO.PW, C.NAME = UPDATEINFO.NAME WHERE ID = UPDATEINFO.ID;
COMMIT;
END;

--checkInfo(?)
CREATE OR REPLACE PROCEDURE CHECKINFO
(PRESULT OUT SYS_REFCURSOR,
ID IN GUESTCUSTOM.ID%TYPE)
IS
BEGIN
OPEN PRESULT FOR
SELECT ID, PW FROM GUESTCUSTOM R WHERE R.ID = CHECKINFO.ID;
COMMIT;
END;

--deleteData(?)
CREATE OR REPLACE PROCEDURE DELETEDATA
(ID IN GUESTCUSTOM.ID%TYPE)
IS
BEGIN
DELETE FROM GUESTRECORD WHERE GUESTRECORD.ID = DELETEDATA.ID;
DELETE FROM GUESTCUSTOM WHERE GUESTCUSTOM.ID = DELETEDATA.ID;
COMMIT;
END;

--printData(?)
CREATE OR REPLACE PROCEDURE PRINTDATA
(PRESULT OUT SYS_REFCURSOR)
IS
BEGIN
OPEN PRESULT FOR
SELECT C.ID, C.PW, C.NAME, R.G_CONTENT, R.CREATED
FROM GUESTCUSTOM C, GUESTRECORD R WHERE C.ID = R.ID;
END;


--현재 테이블이 2개라서 TRIGGER를 만들어서 1번 회원가입을 GUESTCUSTOM에 정보가 생기는데 
--이때 GUESTRECORD에도 자동으로 입력되도록 만듬
--물론 이렇게 안하고 WRITEINFO에서 처리해도 됨.
CREATE OR REPLACE TRIGGER TRI_INSERT
AFTER INSERT ON GUESTCUSTOM
FOR EACH ROW
DECLARE
BEGIN
INSERT INTO GUESTRECORD VALUES (:NEW.ID , '내용을 입력해주세요', SYSDATE);
END;


--방명록을 입력하고 엔터를 치면 날짜에서 오류가 남...
--이유를 모르겠음. 아마 한글 오류라고 생각됨.
--sc.next의 오류였음. 공백도 구분자로 쓰기 때문에
--sc.nextLine을 써서 해결




--writeRecord(?,?,?)
--원래는 사용하는 프로시져 였지만 회원가입을 하면서 자동으로
--GUESTRECORD도 생성이 되게 트리거를 주어서 이제 입력은 안하고 수정으로 가면 될듯
--이건 DROP
---------------------------------------------
--CREATE OR REPLACE PROCEDURE WRITERECORD
--(ID IN GUESTRECORD.ID%TYPE,
--G_CONTENT IN GUESTRECORD.G_CONTENT%TYPE,
--CREATED IN GUESTRECORD.CREATED%TYPE)
--IS
--BEGIN
--INSERT INTO GUESTRECORD(ID,G_CONTENT, CREATED)
--VALUES (ID, G_CONTENT, TO_DATE(CREATED));
--COMMIT;
--END;
--------------------------------------------------


--여기서 한번에 아이디 검사까지 하려고 짠 프로시저인데 그냥 안쓰고 기록만 남김
--updateRecord(?, ?, ?)
CREATE OR REPLACE PROCEDURE UPDATERECORD
(PRESULT OUT SYS_REFCURSOR,
ID IN GUESTRECORD.ID%TYPE,
G_CONTENT IN GUESTRECORD.G_CONTENT%TYPE)
IS
BEGIN
OPEN PRESULT FOR
SELECT ID FROM GUESTRECORD R WHERE R.ID = UPDATERECORD.ID;
IF PRESULT IS NOT NULL THEN
UPDATE GUESTRECORD R SET R.ID = UPDATERECORD.ID, R.G_CONTENT = UPDATERECORD.G_CONTENT, R.CREATED = SYSDATE WHERE ID = UPDATERECORD.ID;
END IF;
COMMIT;
END;
-----------------------------------------------------------------